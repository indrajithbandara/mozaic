<!DOCTYPE html><html><head><title>read.coffee</title><meta http-equiv="Content-Type" content="text/html" charset="UTF-8"><link rel="stylesheet" media="all" href="../../../docco.css"></head><body><div id="container"><div id="background"></div><div id="jump_to">Jump To &hellip;<div id="jump_wrapper"><div id="jump_page"><a href="../../../index.html" class="source"><span class="file_name">README</span></a><a href="../../../core~/api_mock.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">api_mock.coffee</span></a><a href="../../../core~/application_controller.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">application_controller.coffee</span></a><a href="../../../core~/auth.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">auth.coffee</span></a><a href="../../../core~/base_collection.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">base_collection.coffee</span></a><a href="../../../core~/base_model.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">base_model.coffee</span></a><a href="../../../core~/base_widgets/autocomplete.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">autocomplete.coffee</span></a><a href="../../../core~/base_widgets/base_form.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">base_form.coffee</span></a><a href="../../../core~/base_widgets/delete_form.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">delete_form.coffee</span></a><a href="../../../core~/base_widgets/expanding_list.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">expanding_list.coffee</span></a><a href="../../../core~/base_widgets/item_count.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">item_count.coffee</span></a><a href="../../../core~/base_widgets/list.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">list.coffee</span></a><a href="../../../core~/base_widgets/mediator_widget.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">mediator_widget.coffee</span></a><a href="../../../core~/base_widgets/nested_attributes_form.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">nested_attributes_form.coffee</span></a><a href="../../../core~/base_widgets/new_items_count.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">new_items_count.coffee</span></a><a href="../../../core~/base_widgets/notification_bar.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">notification_bar.coffee</span></a><a href="../../../core~/base_widgets/notifications.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">notifications.coffee</span></a><a href="../../../core~/base_widgets/order_by.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">order_by.coffee</span></a><a href="../../../core~/base_widgets/update_form.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">update_form.coffee</span></a><a href="../../../core~/base_widgets/url.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">url.coffee</span></a><a href="../../../core~/base_widgets/user_item_count.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">user_item_count.coffee</span></a><a href="../../../core~/base_widgets/widget_editor.coffee.html" class="source "><span class="base_path">core~ / base_widgets / </span><span class="file_name">widget_editor.coffee</span></a><a href="../../../core~/channels_utils.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">channels_utils.coffee</span></a><a href="../../../core~/constants.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">constants.coffee</span></a><a href="../../../core~/context_processors.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">context_processors.coffee</span></a><a href="../../../core~/controller.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">controller.coffee</span></a><a href="../../../core~/core_modules.js.html" class="source "><span class="base_path">core~ / </span><span class="file_name">core_modules.js</span></a><a href="../../../core~/datasource/channel/create.coffee.html" class="source "><span class="base_path">core~ / datasource / channel / </span><span class="file_name">create.coffee</span></a><a href="../../../core~/datasource/channel/destroy.coffee.html" class="source "><span class="base_path">core~ / datasource / channel / </span><span class="file_name">destroy.coffee</span></a><a href="../../../core~/datasource/channel/read.coffee.html" class="source selected"><span class="base_path">core~ / datasource / channel / </span><span class="file_name">read.coffee</span></a><a href="../../../core~/datasource/channel/update.coffee.html" class="source "><span class="base_path">core~ / datasource / channel / </span><span class="file_name">update.coffee</span></a><a href="../../../core~/datasource/channel.coffee.html" class="source "><span class="base_path">core~ / datasource / </span><span class="file_name">channel.coffee</span></a><a href="../../../core~/datasource/datasource.coffee.html" class="source "><span class="base_path">core~ / datasource / </span><span class="file_name">datasource.coffee</span></a><a href="../../../core~/datasource/gc.coffee.html" class="source "><span class="base_path">core~ / datasource / </span><span class="file_name">gc.coffee</span></a><a href="../../../core~/datasource/refresher.coffee.html" class="source "><span class="base_path">core~ / datasource / </span><span class="file_name">refresher.coffee</span></a><a href="../../../core~/datasource/scheduler.coffee.html" class="source "><span class="base_path">core~ / datasource / </span><span class="file_name">scheduler.coffee</span></a><a href="../../../core~/datasource/widget.coffee.html" class="source "><span class="base_path">core~ / datasource / </span><span class="file_name">widget.coffee</span></a><a href="../../../core~/flags_collection.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">flags_collection.coffee</span></a><a href="../../../core~/interceptor.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">interceptor.coffee</span></a><a href="../../../core~/layout.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">layout.coffee</span></a><a href="../../../core~/loader.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">loader.coffee</span></a><a href="../../../core~/loading_animation.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">loading_animation.coffee</span></a><a href="../../../core~/logging/sentry_logger.coffee.html" class="source "><span class="base_path">core~ / logging / </span><span class="file_name">sentry_logger.coffee</span></a><a href="../../../core~/logging/standard_logger.coffee.html" class="source "><span class="base_path">core~ / logging / </span><span class="file_name">standard_logger.coffee</span></a><a href="../../../core~/mocks.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">mocks.coffee</span></a><a href="../../../core~/modal_window.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">modal_window.coffee</span></a><a href="../../../core~/module.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">module.coffee</span></a><a href="../../../core~/mozaic_backbone_form.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">mozaic_backbone_form.coffee</span></a><a href="../../../core~/profiler.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">profiler.coffee</span></a><a href="../../../core~/pubsub.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">pubsub.coffee</span></a><a href="../../../core~/raw_data.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">raw_data.coffee</span></a><a href="../../../core~/router.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">router.coffee</span></a><a href="../../../core~/scrollable_widget.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">scrollable_widget.coffee</span></a><a href="../../../core~/utils/dom.coffee.html" class="source "><span class="base_path">core~ / utils / </span><span class="file_name">dom.coffee</span></a><a href="../../../core~/utils/images.coffee.html" class="source "><span class="base_path">core~ / utils / </span><span class="file_name">images.coffee</span></a><a href="../../../core~/utils/misc.coffee.html" class="source "><span class="base_path">core~ / utils / </span><span class="file_name">misc.coffee</span></a><a href="../../../core~/utils/mozaic.coffee.html" class="source "><span class="base_path">core~ / utils / </span><span class="file_name">mozaic.coffee</span></a><a href="../../../core~/utils/time.coffee.html" class="source "><span class="base_path">core~ / utils / </span><span class="file_name">time.coffee</span></a><a href="../../../core~/utils/urls.coffee.html" class="source "><span class="base_path">core~ / utils / </span><span class="file_name">urls.coffee</span></a><a href="../../../core~/utils.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">utils.coffee</span></a><a href="../../../core~/widget/aggregated_channels.coffee.html" class="source "><span class="base_path">core~ / widget / </span><span class="file_name">aggregated_channels.coffee</span></a><a href="../../../core~/widget/backbone_events.coffee.html" class="source "><span class="base_path">core~ / widget / </span><span class="file_name">backbone_events.coffee</span></a><a href="../../../core~/widget/channels.coffee.html" class="source "><span class="base_path">core~ / widget / </span><span class="file_name">channels.coffee</span></a><a href="../../../core~/widget/modal_widget.coffee.html" class="source "><span class="base_path">core~ / widget / </span><span class="file_name">modal_widget.coffee</span></a><a href="../../../core~/widget/params.coffee.html" class="source "><span class="base_path">core~ / widget / </span><span class="file_name">params.coffee</span></a><a href="../../../core~/widget/rendering.coffee.html" class="source "><span class="base_path">core~ / widget / </span><span class="file_name">rendering.coffee</span></a><a href="../../../core~/widget/states.coffee.html" class="source "><span class="base_path">core~ / widget / </span><span class="file_name">states.coffee</span></a><a href="../../../core~/widget/widget.coffee.html" class="source "><span class="base_path">core~ / widget / </span><span class="file_name">widget.coffee</span></a><a href="../../../core~/widget_starter.coffee.html" class="source "><span class="base_path">core~ / </span><span class="file_name">widget_starter.coffee</span></a></div></div></div><table cellpadding="0" cellspacing="0"><thead><tr><th class="docs"><h1>read.coffee</h1><div class="filepath">core~/datasource/channel/</div></th><th class="code"></th></tr></thead><tbody><tr id="section-1"><td class="docs"><div class="pilwrap"><a href="#section-1" class="pilcrow">&#182;</a></div>
</td><td class="code"><div class="highlight"><pre><span class="nx">define</span> <span class="p">[</span><span class="s">&#39;cs!channels_utils&#39;</span><span class="p">],</span> <span class="nf">(channels_utils) -&gt;</span>

    <span class="k">class</span> <span class="nx">DataSourceChannelReadMixin</span></pre></div></td></tr><tr id="section-2"><td class="docs"><div class="pilwrap"><a href="#section-2" class="pilcrow">&#182;</a></div><p>Includes methods to read from a http endpoint</p>
</td><td class="code"><div class="highlight"><pre>        <span class="nv">_fetchChannelDataFromServer: </span><span class="nf">(channel, reason=&#39;refresh&#39;, callback=null) -&gt;</span></pre></div></td></tr><tr id="section-3"><td class="docs"><div class="pilwrap"><a href="#section-3" class="pilcrow">&#182;</a></div><p>Fetch the data for the channel given the params.</p>
</td><td class="code"><div class="highlight"><pre></pre></div></td></tr><tr id="section-4"><td class="docs"><div class="pilwrap"><a href="#section-4" class="pilcrow">&#182;</a></div><p>channel: the given channel. The HTTP parameters for fetching
the channel data are taken from @meta<em>data[channel].params
reason: 'refresh' (default), 'streampoll' or 'scroll'
callback: a (channel</em>guid, success) function that will
be called after the fetch is complete
Returns: nothing</p>
</td><td class="code"><div class="highlight"><pre></pre></div></td></tr><tr id="section-5"><td class="docs"><div class="pilwrap"><a href="#section-5" class="pilcrow">&#182;</a></div><p>Sanity check - the only valid reasons for fetching data are
'refresh', 'scroll' and 'streampoll'.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="o">not</span> <span class="p">(</span><span class="nx">reason</span> <span class="k">in</span> <span class="p">[</span><span class="s">&#39;refresh&#39;</span><span class="p">,</span> <span class="s">&#39;scroll&#39;</span><span class="p">,</span> <span class="s">&#39;streampoll&#39;</span><span class="p">])</span>
                <span class="k">throw</span> <span class="s">&quot;Invalid reason: </span><span class="si">#{</span><span class="nx">reason</span><span class="si">}</span><span class="s">&quot;</span>
                <span class="k">return</span>

            <span class="nv">conf = </span><span class="nx">@_getConfig</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span>
            <span class="nv">channel_key = </span><span class="nx">channels_utils</span><span class="p">.</span><span class="nx">getChannelKey</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span>
            <span class="nv">meta = </span><span class="nx">@meta_data</span><span class="p">[</span><span class="nx">channel_key</span><span class="p">]</span></pre></div></td></tr><tr id="section-6"><td class="docs"><div class="pilwrap"><a href="#section-6" class="pilcrow">&#182;</a></div><p>Streampoll doesn't increment waiting fetch count.
Otherwise, when changing tabs periodic requests for new
mentions will NEVER stop, which is just plain wrong.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="nx">reason</span> <span class="o">!=</span> <span class="s">&#39;streampoll&#39;</span>
                <span class="nv">waiting_fetches = </span><span class="k">if</span> <span class="nx">meta</span><span class="p">.</span><span class="nx">waiting_fetches</span> <span class="k">then</span> <span class="nx">meta</span><span class="p">.</span><span class="nx">waiting_fetches</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="nv">meta.waiting_fetches = </span><span class="nx">waiting_fetches</span> <span class="o">+</span> <span class="mi">1</span></pre></div></td></tr><tr id="section-7"><td class="docs"><div class="pilwrap"><a href="#section-7" class="pilcrow">&#182;</a></div><p>Build the current parameters. For normal requests,
they are the current default values overlapped with
the current values (found in @meta<em>data[channel</em>key]).</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nv">default_value = </span><span class="nx">@_getDefaultParams</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span>
            <span class="nv">params = </span><span class="nx">_</span><span class="p">.</span><span class="nx">extend</span><span class="p">({},</span> <span class="nx">default_value</span><span class="p">,</span> <span class="nx">meta</span><span class="p">.</span><span class="nx">params</span><span class="p">)</span></pre></div></td></tr><tr id="section-8"><td class="docs"><div class="pilwrap"><a href="#section-8" class="pilcrow">&#182;</a></div><p>If we're fetching on behalf of a scroll / streampoll request,
make sure that we give the scroll/streampoll_params function
the opportunity to modify the current HTTP params.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="nx">reason</span> <span class="k">in</span> <span class="p">[</span><span class="s">&#39;scroll&#39;</span><span class="p">,</span> <span class="s">&#39;streampoll&#39;</span><span class="p">]</span>
                <span class="nv">fn_name = </span><span class="nx">reason</span> <span class="o">+</span> <span class="s">&#39;_params&#39;</span>
                <span class="k">if</span> <span class="o">not</span> <span class="p">(</span><span class="nx">fn_name</span> <span class="k">of</span> <span class="nx">conf</span><span class="p">)</span>
                    <span class="nx">logger</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s">&quot;Configuration for channel </span><span class="si">#{</span><span class="nx">channel_key</span><span class="si">}</span><span class="s"> should have function </span><span class="si">#{</span><span class="nx">fn_name</span><span class="si">}</span><span class="s">&quot;</span><span class="p">)</span>
                    <span class="k">return</span></pre></div></td></tr><tr id="section-9"><td class="docs"><div class="pilwrap"><a href="#section-9" class="pilcrow">&#182;</a></div><p>Retrieve the new parameters</p>
</td><td class="code"><div class="highlight"><pre>                <span class="nv">params = </span><span class="nx">conf</span><span class="p">[</span><span class="nx">fn_name</span><span class="p">](</span><span class="nx">@data</span><span class="p">[</span><span class="nx">channel_key</span><span class="p">],</span> <span class="nx">params</span><span class="p">)</span>
                <span class="k">if</span> <span class="o">not</span> <span class="nx">params</span></pre></div></td></tr><tr id="section-10"><td class="docs"><div class="pilwrap"><a href="#section-10" class="pilcrow">&#182;</a></div><p>Cancel the current streampoll/scroll request if params == null.
Careful - emtpy dict { } evaluates to true in JavaScript!</p>
</td><td class="code"><div class="highlight"><pre>                    <span class="k">return</span></pre></div></td></tr><tr id="section-11"><td class="docs"><div class="pilwrap"><a href="#section-11" class="pilcrow">&#182;</a></div><p>If the encode<em>POST</em>as_JSON flag is set, instead of URL-encoding
the parameters as for normal forms, send them encoded as JSON.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">fetch_through_POST</span> <span class="o">and</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">encode_POST_as_JSON</span>
                <span class="nv">params_for_fetch = </span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span>
            <span class="k">else</span>
                <span class="nv">params_for_fetch = </span><span class="nx">_</span><span class="p">.</span><span class="nx">clone</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span></pre></div></td></tr><tr id="section-12"><td class="docs"><div class="pilwrap"><a href="#section-12" class="pilcrow">&#182;</a></div><p>Channel has an associated URL. Fetch data from that URL.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nv">fetch_params =</span>
                <span class="nv">async: </span><span class="nx">@_async_fetches</span></pre></div></td></tr><tr id="section-13"><td class="docs"><div class="pilwrap"><a href="#section-13" class="pilcrow">&#182;</a></div><p>Don't add models on refresh (reset entire collection instead).</p>
</td><td class="code"><div class="highlight"><pre>                <span class="nv">add: </span><span class="nx">reason</span> <span class="o">!=</span> <span class="s">&#39;refresh&#39;</span></pre></div></td></tr><tr id="section-14"><td class="docs"><div class="pilwrap"><a href="#section-14" class="pilcrow">&#182;</a></div><p>For POST requests, the URL should contain no extra GET params,
and those params should rather be sent through POST data.
This is because we might have large data to POST,
and as we all know, the GET URI has a pretty low length limit.</p>
</td><td class="code"><div class="highlight"><pre>                <span class="nv">type: </span><span class="k">if</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">fetch_through_POST</span> <span class="k">then</span> <span class="s">&#39;POST&#39;</span> <span class="k">else</span> <span class="s">&#39;GET&#39;</span>
                <span class="nv">data: </span><span class="k">if</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">fetch_through_POST</span> <span class="k">then</span> <span class="nx">params_for_fetch</span> <span class="k">else</span> <span class="p">{}</span></pre></div></td></tr><tr id="section-15"><td class="docs"><div class="pilwrap"><a href="#section-15" class="pilcrow">&#182;</a></div><p>When the data is encoded as JSON, be careful to set the correct
content-type.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">fetch_through_POST</span> <span class="o">and</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">encode_POST_as_JSON</span>
                <span class="nv">fetch_params.contentType = </span><span class="s">&#39;application/json&#39;</span></pre></div></td></tr><tr id="section-16"><td class="docs"><div class="pilwrap"><a href="#section-16" class="pilcrow">&#182;</a></div><p>Story behind this decision to insert a fetched callback before triggering reset:
When you are binding a widget to a collection (datasource.<em>bindWidgetToRelationalChannel)
you are doing 2 things:
1. widget is subscribed to all collection events ('reset' included):
   - if collection is updated then the widget is notified to refresh contents
2. if the collection is already filled: @meta</em>data[collection].last<em>fetch?
   then the widget is notified to refresh contents
With a fetched event before reset you are setting meta.last</em>fetch eliminating a race condition
where 'reset' event will cause a bindWidgetToRelationalChannel
the step 2 above will find last_fetch null thus leaving the widget empty</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nv">fetch_params.fetched = </span><span class="o">=&gt;</span>
                <span class="nv">meta.firstTimeFetch = </span><span class="o">!</span><span class="nx">meta</span><span class="p">.</span><span class="nx">last_fetch</span><span class="o">?</span>
                <span class="nv">meta.last_fetch = </span><span class="nx">Utils</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span></pre></div></td></tr><tr id="section-17"><td class="docs"><div class="pilwrap"><a href="#section-17" class="pilcrow">&#182;</a></div><p>Define success &amp; error functions as wrappers around callback.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nv">fetch_params.success = </span><span class="nf">(collection, response) =&gt;</span></pre></div></td></tr><tr id="section-18"><td class="docs"><div class="pilwrap"><a href="#section-18" class="pilcrow">&#182;</a></div><p>Ignore response if channel was removed in the meantime
One scenario for this happening is a really slow API call
while user changes the page and channel gets garbage
collected.</p>
</td><td class="code"><div class="highlight"><pre>                <span class="k">return</span> <span class="k">unless</span> <span class="nx">@reference_data</span><span class="p">[</span><span class="nx">channel_key</span><span class="p">]</span><span class="o">?</span>

                <span class="nx">@_checkForNewlyArrivedAndAwaitedModels</span><span class="p">(</span><span class="nx">channel_key</span><span class="p">)</span></pre></div></td></tr><tr id="section-19"><td class="docs"><div class="pilwrap"><a href="#section-19" class="pilcrow">&#182;</a></div><p>Only fill waiting channels the first time this
channel receives data.</p>
</td><td class="code"><div class="highlight"><pre>                <span class="k">if</span> <span class="nx">meta</span><span class="p">.</span><span class="nx">firstTimeFetch</span>
                    <span class="nx">@_fillWaitingChannels</span><span class="p">(</span><span class="nx">channel_key</span><span class="p">)</span>
                <span class="k">if</span> <span class="nx">reason</span> <span class="o">!=</span> <span class="s">&#39;streampoll&#39;</span>
                    <span class="nv">meta.waiting_fetches = </span><span class="nx">meta</span><span class="p">.</span><span class="nx">waiting_fetches</span> <span class="o">-</span> <span class="mi">1</span></pre></div></td></tr><tr id="section-20"><td class="docs"><div class="pilwrap"><a href="#section-20" class="pilcrow">&#182;</a></div><p>Call the post fetching callback if the collection
has one set</p>
</td><td class="code"><div class="highlight"><pre>                <span class="k">if</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isFunction</span><span class="p">(</span><span class="nx">collection</span><span class="p">.</span><span class="nx">postFetch</span><span class="p">)</span>
                    <span class="nx">collection</span><span class="p">.</span><span class="nx">postFetch</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span>

                <span class="nx">callback</span><span class="p">(</span><span class="nx">channel_key</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="k">if</span> <span class="nx">callback</span>
            <span class="nv">fetch_params.error = </span><span class="nf">(collection, response) =&gt;</span></pre></div></td></tr><tr id="section-21"><td class="docs"><div class="pilwrap"><a href="#section-21" class="pilcrow">&#182;</a></div><p>Ignore response if channel was removed in the meantime</p>
</td><td class="code"><div class="highlight"><pre>                <span class="k">return</span> <span class="k">unless</span> <span class="nx">@reference_data</span><span class="p">[</span><span class="nx">channel_key</span><span class="p">]</span><span class="o">?</span>
                <span class="nx">callback</span><span class="p">(</span><span class="nx">channel_key</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="k">if</span> <span class="nx">callback</span></pre></div></td></tr><tr id="section-22"><td class="docs"><div class="pilwrap"><a href="#section-22" class="pilcrow">&#182;</a></div><p>What channel should receive the data we're about to fetch -
the original channel, or that channel's buffer?
(The first fetch should always be into the real channel).</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="nx">reason</span> <span class="o">==</span> <span class="s">&#39;streampoll&#39;</span> <span class="o">and</span> <span class="nx">@_getBufferSize</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span> <span class="o">and</span> <span class="nx">@meta_data</span><span class="p">[</span><span class="nx">channel_key</span><span class="p">].</span><span class="nx">last_fetch</span><span class="o">?</span>
                <span class="nv">receiving_channel = </span><span class="nx">@data</span><span class="p">[</span><span class="nx">channel_key</span><span class="p">].</span><span class="nx">buffer</span></pre></div></td></tr><tr id="section-23"><td class="docs"><div class="pilwrap"><a href="#section-23" class="pilcrow">&#182;</a></div><p>If the buffer is full, avoid doing any more fetches.</p>
</td><td class="code"><div class="highlight"><pre>                <span class="k">if</span> <span class="nx">receiving_channel</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">buffer_size</span>
                    <span class="k">return</span>
            <span class="k">else</span>
                <span class="nv">receiving_channel = </span><span class="nx">@data</span><span class="p">[</span><span class="nx">channel_key</span><span class="p">]</span></pre></div></td></tr><tr id="section-24"><td class="docs"><div class="pilwrap"><a href="#section-24" class="pilcrow">&#182;</a></div><p>Render the URL to which we're GET-ing or POST-ing.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nv">receiving_channel.url = </span><span class="nx">Utils</span><span class="p">.</span><span class="nx">render_url</span><span class="p">(</span><span class="nx">conf</span><span class="p">.</span><span class="nx">url</span><span class="p">,</span> <span class="nx">params</span><span class="p">,</span> <span class="p">[],</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">fetch_through_POST</span><span class="p">)</span></pre></div></td></tr><tr id="section-25"><td class="docs"><div class="pilwrap"><a href="#section-25" class="pilcrow">&#182;</a></div><p>Trigger a custom invalidate event before fetching the
collection from the server (invalidate gets triggered
every time a request is made to the server). The format
of the event is: model, collection</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nx">receiving_channel</span><span class="p">.</span><span class="nx">trigger</span><span class="p">(</span><span class="s">&#39;invalidate&#39;</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">receiving_channel</span><span class="p">)</span>
            <span class="nx">receiving_channel</span><span class="p">.</span><span class="nx">fetch</span><span class="p">(</span><span class="nx">fetch_params</span><span class="p">)</span>

        <span class="nv">_checkForNewlyArrivedAndAwaitedModels: </span><span class="nf">(channel) -&gt;</span></pre></div></td></tr><tr id="section-26"><td class="docs"><div class="pilwrap"><a href="#section-26" class="pilcrow">&#182;</a></div><p>Checks if some new models which were awaited for have appeared
into the given channel. If there are, bind the respective
widgets to the individual models and drop the widget references.</p>
</td><td class="code"><div class="highlight"><pre></pre></div></td></tr><tr id="section-27"><td class="docs"><div class="pilwrap"><a href="#section-27" class="pilcrow">&#182;</a></div><p>Check if channel still exists</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="o">not</span> <span class="p">(</span><span class="nx">channel</span> <span class="k">of</span> <span class="nx">@meta_data</span><span class="p">)</span>
                <span class="nx">logger</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="s">&quot;Channel </span><span class="si">#{</span><span class="nx">channel</span><span class="si">}</span><span class="s"> has probably been garbage collected too early&quot;</span><span class="p">)</span>
                <span class="k">return</span></pre></div></td></tr><tr id="section-28"><td class="docs"><div class="pilwrap"><a href="#section-28" class="pilcrow">&#182;</a></div><p>Check if channel has pending items to wait for</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="o">not</span> <span class="p">(</span><span class="s">&#39;delayed_single_items&#39;</span> <span class="k">of</span> <span class="nx">@meta_data</span><span class="p">[</span><span class="nx">channel</span><span class="p">])</span>
                <span class="k">return</span>

            <span class="nv">remaining_delayed_items = </span><span class="p">[]</span>
            <span class="k">for</span> <span class="nx">delayed_item</span> <span class="k">in</span> <span class="nx">@meta_data</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">delayed_single_items</span>
                <span class="nv">single_item = </span><span class="nx">@data</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nx">get</span><span class="p">(</span><span class="nx">delayed_item</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span></pre></div></td></tr><tr id="section-29"><td class="docs"><div class="pilwrap"><a href="#section-29" class="pilcrow">&#182;</a></div><p>If the item still hasn't appeared, plan it for later re-use</p>
</td><td class="code"><div class="highlight"><pre>                <span class="k">if</span> <span class="o">not</span> <span class="nx">single_item</span>
                    <span class="nx">remaining_delayed_items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">delayed_item</span><span class="p">)</span>
                    <span class="k">continue</span></pre></div></td></tr><tr id="section-30"><td class="docs"><div class="pilwrap"><a href="#section-30" class="pilcrow">&#182;</a></div><p>Otherwise, do the binding and drop the widget reference</p>
</td><td class="code"><div class="highlight"><pre>                <span class="k">else</span>
                    <span class="nx">@_bindWidgetToRelationalChannel</span><span class="p">(</span><span class="nx">delayed_item</span><span class="p">.</span><span class="nx">fake_channel</span><span class="p">,</span>
                                                    <span class="nx">delayed_item</span><span class="p">.</span><span class="nx">channel</span><span class="p">,</span>
                                                    <span class="nx">delayed_item</span><span class="p">.</span><span class="nx">widget_data</span><span class="p">)</span></pre></div></td></tr><tr id="section-31"><td class="docs"><div class="pilwrap"><a href="#section-31" class="pilcrow">&#182;</a></div><p>Check if there are still single items to wait for</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="nx">remaining_delayed_items</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="nx">@meta_data</span><span class="p">[</span><span class="nx">channel</span><span class="p">].</span><span class="nv">delayed_single_items = </span><span class="nx">remaining_delayed_items</span>
            <span class="k">else</span>
                <span class="k">delete</span> <span class="nx">@meta_data</span><span class="p">[</span><span class="nx">channel</span><span class="p">][</span><span class="s">&#39;delayed_single_items&#39;</span><span class="p">]</span>

        <span class="nv">_fillWaitingChannels: </span><span class="nf">(channel_guid) -&gt;</span></pre></div></td></tr><tr id="section-32"><td class="docs"><div class="pilwrap"><a href="#section-32" class="pilcrow">&#182;</a></div><p>Try to fill each waiting channel that is a duplicate of
this one.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nv">duplicates = </span><span class="nx">@_getChannelDuplicates</span><span class="p">(</span><span class="nx">channel_guid</span><span class="p">)</span>
            <span class="k">for</span> <span class="nx">dest_channel_guid</span> <span class="k">in</span> <span class="nx">duplicates</span>
                <span class="k">if</span> <span class="o">not</span> <span class="nx">@meta_data</span><span class="p">[</span><span class="nx">dest_channel_guid</span><span class="p">].</span><span class="nx">last_fetch</span><span class="o">?</span></pre></div></td></tr><tr id="section-33"><td class="docs"><div class="pilwrap"><a href="#section-33" class="pilcrow">&#182;</a></div><p>If dest_channel does not yet have data, clone into it
by using this channel as clone source.</p>
</td><td class="code"><div class="highlight"><pre>                    <span class="nx">@_cloneChannel</span><span class="p">(</span><span class="nx">dest_channel_guid</span><span class="p">,</span> <span class="nx">channel_guid</span><span class="p">)</span>

        <span class="nv">_flushChannelBuffer: </span><span class="nf">(channel_guid) -&gt;</span></pre></div></td></tr><tr id="section-34"><td class="docs"><div class="pilwrap"><a href="#section-34" class="pilcrow">&#182;</a></div><p>Flush channel buffer by moving buffer data into channel data,
then reset buffer.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nx">logger</span><span class="p">.</span><span class="nx">info</span> <span class="s">&quot;Flushing channel </span><span class="si">#{</span><span class="nx">channel_guid</span><span class="si">}</span><span class="s"> buffer&quot;</span>
            <span class="nv">channel = </span><span class="nx">@data</span><span class="p">[</span><span class="nx">channel_guid</span><span class="p">]</span>

            <span class="nv">conf = </span><span class="nx">@_getConfig</span><span class="p">(</span><span class="nx">channel_guid</span><span class="p">)</span></pre></div></td></tr><tr id="section-35"><td class="docs"><div class="pilwrap"><a href="#section-35" class="pilcrow">&#182;</a></div><p>Get where to append the buffered items: 'begin' or 'end'</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nv">add_to = </span><span class="nx">conf</span><span class="p">.</span><span class="nx">streampoll_add_to</span> <span class="o">||</span> <span class="s">&#39;end&#39;</span></pre></div></td></tr><tr id="section-36"><td class="docs"><div class="pilwrap"><a href="#section-36" class="pilcrow">&#182;</a></div><p>Get the field after which to sort the buffer items</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nv">sort_field = </span><span class="nx">conf</span><span class="p">.</span><span class="nx">streampoll_sort_field</span></pre></div></td></tr><tr id="section-37"><td class="docs"><div class="pilwrap"><a href="#section-37" class="pilcrow">&#182;</a></div><p>Sort the buffer items before flushing</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nv">channel.buffer.models = </span><span class="nx">_</span><span class="p">.</span><span class="nx">sortBy</span><span class="p">(</span><span class="nx">channel</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">models</span><span class="p">,</span> <span class="nf">(model) -&gt;</span> <span class="nx">model</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">sort_field</span><span class="p">))</span> <span class="k">if</span> <span class="nx">sort_field</span><span class="o">?</span></pre></div></td></tr><tr id="section-38"><td class="docs"><div class="pilwrap"><a href="#section-38" class="pilcrow">&#182;</a></div><p>If we add to the beginning, we take the elements in reverse order
from the buffer and add each element to the beginning.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="nx">add_to</span> <span class="o">==</span> <span class="s">&#39;begin&#39;</span>
                <span class="k">while</span> <span class="nx">channel</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="nv">model = </span><span class="nx">channel</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span>
                    <span class="nx">channel</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">model</span><span class="p">)</span></pre></div></td></tr><tr id="section-39"><td class="docs"><div class="pilwrap"><a href="#section-39" class="pilcrow">&#182;</a></div><p>Otherwise, just append the whole buffer to the end of the collection</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">else</span> <span class="k">if</span> <span class="nx">add_to</span> <span class="o">==</span> <span class="s">&#39;end&#39;</span></pre></div></td></tr><tr id="section-40"><td class="docs"><div class="pilwrap"><a href="#section-40" class="pilcrow">&#182;</a></div><p>Add all models from buffer into channel, without event silencing.</p>
</td><td class="code"><div class="highlight"><pre>                <span class="nx">channel</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">channel</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">models</span><span class="p">)</span></pre></div></td></tr><tr id="section-41"><td class="docs"><div class="pilwrap"><a href="#section-41" class="pilcrow">&#182;</a></div><p>Reset buffer without triggering any events.</p>
</td><td class="code"><div class="highlight"><pre>                <span class="nx">channel</span><span class="p">.</span><span class="nx">buffer</span><span class="p">.</span><span class="nx">reset</span><span class="p">([])</span>

            <span class="nx">@_restartRefreshing</span><span class="p">(</span><span class="nx">channel_guid</span><span class="p">)</span>

        <span class="nv">_getBufferSize: </span><span class="nf">(channel) -&gt;</span></pre></div></td></tr><tr id="section-42"><td class="docs"><div class="pilwrap"><a href="#section-42" class="pilcrow">&#182;</a></div><p>Returns the buffer size for a given channel (0 for no buffer).</p>
</td><td class="code"><div class="highlight"><pre>            <span class="nv">conf = </span><span class="nx">@_getConfig</span><span class="p">(</span><span class="nx">channel</span><span class="p">)</span></pre></div></td></tr><tr id="section-43"><td class="docs"><div class="pilwrap"><a href="#section-43" class="pilcrow">&#182;</a></div><p>Only streampoll channels may have buffers.</p>
</td><td class="code"><div class="highlight"><pre>            <span class="k">if</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">refresh_type</span> <span class="o">==</span> <span class="s">&#39;streampoll&#39;</span> <span class="o">and</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">buffer_size</span><span class="o">?</span>
                <span class="k">return</span> <span class="nx">conf</span><span class="p">.</span><span class="nx">buffer_size</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="mi">0</span>

</pre></div></td></tr></tbody></table><div id="generated">generated Mon Aug 05 2013 15:56:36 GMT+0300 (EEST)  </div></div></body></html>